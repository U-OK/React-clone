<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>React-clone</title>
</head>
<body>
<div id="root">
</div>
</body>
<script>

    function checkIsWorking() {
        return Math.random() < 0.5
    }

    function getWorkers() {
        return new Promise((resolve) => {
            setTimeout(() => resolve(
                [
                    {
                        name: 'Денис Мартынов',
                        isWorking: checkIsWorking()
                    },
                    {
                        name: 'Окунцев Юрий',
                        isWorking: checkIsWorking()
                    },
                    {
                        name: 'Александр Богатиков',
                        isWorking: checkIsWorking()
                    },
                    {
                        name: 'Денис Крылов',
                        isWorking: checkIsWorking()
                    },
                ]
            ), 1000)
        })
    }

    let state = {
        time: new Date(),
        workers: null,
    };

    function Header() {
        return {
            type: 'header',
            props: {
                children: [
                    {
                        type: Logo,
                        props: {}
                    }
                ]
            }
        }
    }

    function Logo() {
        return {
            type: 'img',
            props: {
                src: 'images/logo.png',
                alt: 'kozhindev.com',
            }
        }
    }

    function Main({props}) {
        return {
            type: 'main',
            props: {
                props,
                children: [
                    {
                        type: Title,
                        props: {},
                    },
                    {
                        type: Article,
                        props: {
                            time: props.time,
                            workers: props.workers,
                        }
                    }
                ]
            }
        };
    }

    function Title() {
        return {
            type: 'h1',
            props: {
                children: [
                    'KozhinDev'
                ]
            }
        };
    }

    function Article({time, workers}) {
        return {
            type: 'article',
            props: {
                children: [
                    {
                        type: WorkTime,
                        props: {}
                    },
                    {
                        type: CurrentTime,
                        props: {
                            time
                        }
                    },
                    {
                        type: Status,
                        props: {
                            time
                        }
                    },
                    {
                        type: Workers,
                        props: {
                            workers
                        }
                    }
                ]
            }
        }
    }

    function WorkTime() {
        return {
            type: 'p',
            props: {
                children: [
                    'Часы работы: с 8:00 до 19:00'
                ]
            }
        };
    }

    function CurrentTime({time}) {
        return {
            type: 'small',
            props: {
                className: 'CurrentTime',
                children: [
                    'Сейчас: ' + time.toLocaleTimeString()
                ]
            }
        }
    }

    function Status({time}) {
        return {
            type: 'strong',
            props: {
                className: 'Status',
                children: [
                    (time.getHours() < 8) || (time.getHours() > 19)
                        ? ' Закрыто'
                        : ' Открыто'
                ]
            }
        };
    }

    function Workers({workers}) {
        if (!workers) {
            return {
                type: 'div',
                props: {
                    children: [
                        'Загрузка...'
                    ]
                }
            };
        }

        return {
            type: 'div',
            props: {
                children: workers.filter(worker => worker.isWorking)
                    .map(worker => ({
                        type: 'div',
                        props: {
                            key: worker.name,
                            children: [
                                worker.name + '  '
                            ]
                        }
                    }))
            }
        };
    }

    function App(state) {
        return {
            type: 'div',
            props: {
                className: 'App',
                children: [
                    {
                        type: Header,
                        props: {}
                    },
                    {
                        type: Main,
                        props: {
                            props: state
                        }
                    }
                ]
            }
        };
    }

    setInterval(() => {
        getWorkers().then((workers) => {
            state = {
                ...state,
                workers
            }
        })

        state = {
            ...state,
            time: new Date(),
        }

        render(App(state), document.getElementById('root'))
    }, 1000)

    render(
        App(state),
        document.getElementById('root')
    );

    function render(virtualDOM, realDOMRoot) {
        const interpretVirtualDOM = interpret(virtualDOM);

        const virtualDOMRoot = {
            type: realDOMRoot.tagName.toLowerCase(),
            props: {
                children: [
                    interpretVirtualDOM
                ]
            }
        }

        sync(virtualDOMRoot, realDOMRoot)
    }

    function interpret(virtualNode) {
        if (typeof virtualNode !== 'object') {
            return virtualNode
        }

        if (typeof virtualNode.type === 'function') {
            return interpret((virtualNode.type)(virtualNode.props))
        }

        const props = virtualNode.props || {}

        return {
            ...virtualNode,
            props: {
                ...props,
                children: Array.isArray(props.children) ? props.children.map(interpret) : [interpret(props.children)]
            }
        }
    }

    function sync(virtualNode, realNode) {
        // Синхронизация пропсов
        if (virtualNode.props) {
            Object.entries(virtualNode.props).forEach(([name, value]) => {
                if (name === 'key' || name === 'children') {
                    return
                }
                if (realNode[name] !== value) {
                    realNode[name] = value
                }
            })
        }
        // debugger
        // случай для пограничного состояния, когда вместо полноценного узла приходит Node.TEXT_NODE
        if (typeof virtualNode !== 'object' && virtualNode !== realNode.nodeValue) {
            realNode.nodeValue = virtualNode
        }

        // Синхронизация дочерних узлов
        const virtualChildren = virtualNode.props ? virtualNode.props.children || [] : []
        const realChildren = realNode.childNodes;

        for (let i = 0; i < virtualChildren.length || i < realChildren.length; i++) {
            const virtual = virtualChildren[i]
            const real = realChildren[i];

            // Если виртуального узла нет, а реальный есть - удаляем
            if (virtual === undefined && real !== undefined) {
                realNode.remove(real);
            }

            // Если виртуальный и реальный дом - один и тот же HTML тэг, то мы их синхронизируем
            if (virtual !== undefined && real !== undefined && (virtual.type || '') === (real.tagName?.toLowerCase() || '')) {
                sync(virtual, real)
            }

            // Если тэги ни совпадают, то мы создаем такой тэг и синхронизируем с виртуальным
            if (virtual !== undefined && real !== undefined && (virtual.type || '') !== (real.tagName?.toLowerCase() || '')) {
                const newReal = constructRealNodeByVirtualNode(virtual)
                sync(virtual, newReal)
                realNode.replaceChild(newReal, real)
            }

            // Добавление нового узла
            if (virtual !== undefined && real === undefined) {
                const newReal = constructRealNodeByVirtualNode(virtual)
                sync(virtual, newReal)
                realNode.appendChild(newReal)
            }
        }
    }

    function constructRealNodeByVirtualNode(virtualNode) {
        return typeof virtualNode !== 'object'
            ? document.createTextNode('')
            : document.createElement(virtualNode.type)
    }

</script>
</html>